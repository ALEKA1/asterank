<!doctype html>
<html>
	<head>
		<title>Asterank - 3D Asteroid Orbit Space Simulation</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link  href="css/main.css" rel="stylesheet"/>
	</head>
<body>
  <noscript>Sorry, this page requires Canvas/WebGL, so you'll need to enable JavaScript.</noscript>

  <script type="x-shader/x-vertex" id="vertexshader">
    #define pi 3.141592653589793238462643383279

    varying vec2 vUv;

    attribute vec3 value_color;
    varying vec3 vColor;

    attribute float size;

    uniform float earth_i;
    uniform float earth_om;
    uniform float time;

    uniform float jed;

    attribute float a;
    attribute float e;
    attribute float i;
    attribute float o;
    attribute float P;
    attribute float ma;
    attribute float n;
    attribute float w;
    attribute float epoch;

    attribute float locked;
    varying float vLocked;

    vec3 getAstroPos() {
      float i_rad = (i - earth_i) * pi/180.0;
      float o_rad = (o - earth_om) * pi/180.0; // longitude of ascending node
      float p_rad = w * pi/180.0; // longitude of perihelion
      float ma_rad = ma * pi/180.0;
      float n_rad;
      if (n > -1.0)
        n_rad = n * pi/180.0; // mean motion
      else {
        n_rad = 2.0 * pi / P;
      }

      float d = epoch - jed;
      float M = ma_rad + n_rad * -d;

      // Estimate eccentric and true anom using iterative approx
      float E0 = M;
      float lastdiff;
      // converted do/while:
      float E1 = M + e * sin(E0);
      lastdiff = abs(E1-E0);
      E0 = E1;
      for (int foo=0; foo < 6; foo++) {
        float E1 = M + e * sin(E0);
        lastdiff = abs(E1-E0);
        E0 = E1;
        if (lastdiff > 0.0000001) {
          break;
        }
      }
      float E = E0;
      float v = 2.0 * atan(sqrt((1.0+e)/(1.0-e)) * tan(E/2.0));

      // radius vector, in AU
      float r = a * (1.0 - e*e) / (1.0 + e * cos(v)) * {{PIXELS_PER_AU}};

      // heliocentric coords
      float X = r * (cos(o_rad) * cos(v + p_rad - o_rad) - sin(o_rad) * sin(v + p_rad - o_rad) * cos(i_rad));
      float Y = r * (sin(o_rad) * cos(v + p_rad - o_rad) + cos(o_rad) * sin(v + p_rad - o_rad) * cos(i_rad));
      float Z = r * (sin(v + p_rad - o_rad) * sin(i_rad));
      return vec3(X, Y, Z);
    }


float rand(vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

    void main() {
      vColor = value_color;
      vLocked = locked;

      //vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      vec3 newpos = getAstroPos();
      vec4 mvPosition = modelViewMatrix * vec4(newpos, 1.0);
      gl_Position = projectionMatrix * mvPosition;
      gl_PointSize = size;
      //vUv = uv2;
    }
  </script>
  <script type="x-shader/x-fragment" id="fragmentshader">
    varying vec2 vUv;
    varying vec3 vColor;
    varying float vLocked;
    uniform vec3 color;
    uniform sampler2D small_roid_texture;
    uniform sampler2D small_roid_circled_texture;

    void main() {
      //gl_FragColor = texture2D(small_roid_texture, vUv);
      //vec4 sum = texture2D(small_roid_texture,
        //vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));
     //gl_FragColor = sum;
//vec2 pos = mod(gl_PointCoord.xy, vec2(0.5, 0.5));
      if (vLocked == 0.0) {
      gl_FragColor = vec4(vColor, 1.0) * texture2D(small_roid_texture,
        vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));
      }
      else {
      gl_FragColor = vec4(vColor, 1.0) * texture2D(small_roid_circled_texture,
        vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));
      }
      /*
      float xs = gl_PointCoord.x - 0.5;
      float ys = gl_PointCoord.y - 0.5;
      float dist = sqrt(xs*xs + ys*ys);
      if (dist > 0.25) {
        gl_FragColor = texture2D(small_roid_texture,
          vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y))
          * vec4(1.0, 1.0, 1.0, 0.5);
      }
      else {
        gl_FragColor = texture2D(small_roid_texture,
          vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));
      }
        */
      /*
      float opacity;
      if (dist > 0.25) {
        discard;
        return;
      }
      else if (dist < 0.05) {
        opacity = 1.0;
      }
      else {
        opacity = 0.1;
      }
      gl_FragColor = vec4(color, opacity);
       */
    }
  </script>
  <script type="x-shader/x-vertex" id="bigparticle-vertexshader">
    #define pi 3.141592653589793238462643383279

    uniform float earth_i;
    uniform float earth_om;

    uniform float jed;

    uniform float a;
    uniform float e;
    uniform float i;
    uniform float o;
    uniform float ma;
    uniform float n;
    uniform float w;
    uniform float P;
    uniform float epoch;

    vec3 getAstroPos() {
      float i_rad = (i - earth_i) * pi/180.0;
      float o_rad = (o - earth_om) * pi/180.0; // longitude of ascending node
      float p_rad = w * pi/180.0; // longitude of perihelion
      float ma_rad = ma * pi/180.0;
      float n_rad;
      if (n > -1.0)
        n_rad = n * pi/180.0; // mean motion
      else {
        n_rad = 2.0 * pi / P;
      }

      float d = epoch - jed;
      float M = ma_rad + n_rad * -d;

      // Estimate eccentric and true anom using iterative approx
      float E0 = M;
      float lastdiff;
      // converted do/while:
      float E1 = M + e * sin(E0);
      lastdiff = abs(E1-E0);
      E0 = E1;
      for (int foo=0; foo < 5000; foo++) {
        float E1 = M + e * sin(E0);
        lastdiff = abs(E1-E0);
        E0 = E1;
        if (lastdiff > 0.0000001) {
          break;
        }
      }
      float E = E0;
      float v = 2.0 * atan(sqrt((1.0+e)/(1.0-e)) * tan(E/2.0));

      // radius vector, in AU
      float r = a * (1.0 - e*e) / (1.0 + e * cos(v)) * {{PIXELS_PER_AU}};

      // heliocentric coords
      float X = r * (cos(o_rad) * cos(v + p_rad - o_rad) - sin(o_rad) * sin(v + p_rad - o_rad) * cos(i_rad));
      float Y = r * (sin(o_rad) * cos(v + p_rad - o_rad) + cos(o_rad) * sin(v + p_rad - o_rad) * cos(i_rad));
      float Z = r * (sin(v + p_rad - o_rad) * sin(i_rad));
      return vec3(X, Y, Z);
    }

    void main() {
      gl_Position = vec4(10., 10., 10., 1.);
      gl_PointSize = 30.0;

      // ....
      return;
      vec3 newpos = getAstroPos();
      vec4 mvPosition = modelViewMatrix * vec4(newpos, 1.0);
      gl_Position = projectionMatrix * mvPosition;
      gl_PointSize = 30.0;
    }
  </script>
  <script type="x-shader/x-fragment" id="bigparticle-fragmentshader">
    void main() {
      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
    }
  </script>

  <div id="sidebar">
    <p>
    <a href="/">&laquo; Main site</a>
    </p>
    <div class="fb-like" data-href="http://www.asterank.com/3d" data-send="false" data-layout="button_count" data-width="450" data-show-faces="false"></div>
    <a style="font-size:10px;" href="https://twitter.com/share" class="twitter-share-button" data-lang="en">Tweet</a>

    <hr/>
    <div id="objects-of-interest-container" style="text-align:center;display:none;">
      <span>Significant Objects</span>
      <table id="objects-of-interest">
        <tr id="sun-selector" data-full-name="sun" style="background-color:green;">
          <td colspan="2"><a href="#">Sun</a> (default view)</td>
        </tr>
        <!--
        <tr>
          <td colspan="2" data-full-name="earth">Earth</td>
        </tr>
        -->
      </table>

    </div>
  </div>
    <!--
  <div id="controls">
    <select id="search-type">
      <option value="score">Most cost effective</option>
      <option value="price">Most valuable</option>
      <option value="closeness">Most accessible</option>
    </select>
    <input type="button" value="Update"/>
    <a href="#" class="js-sort" data-sort="score" style="font-weight:bold;">Most cost effective</a>
    <a href="#" class="js-sort" data-sort="price">Most valuable</a>
    <a href="#" class="js-sort" data-sort="closeness">Most accessible</a>
    <input id="btn-toggle-movement" type="button" value="Toggle Movement"/>
  </div>
    -->
	<!-- three.js container -->
  <div id="container"></div>
	<!-- info on screen display -->
  <div id="loading">
    <img src="/images/loader.gif"/> Loading...
  </div>
	<div id="info">
    <div id="caption-container">
      <div id="main-caption" class="top">
      </div>
      <div id="other-caption" class="top">
      </div>
    </div>
		<div class="bottom" id="inlineDoc" >
      <span style="font-size:12px;margin-right:10px;color:#fff">
      <strong>Rotate</strong>: left click + drag; <strong>Pan</strong>: right click + drag; <strong>Zoom</strong>: scroll/middle click + drag
      <br>
      Hover over the big white asteroids for economic estimates.
      <br>
      The locations of asteroids and planets shown are scientifically accurate.</span>
<!--
      <span style="background-color:#913CEE;color:#000">Mercury</span>
      <span style="background-color:#ff7733;color:#000">Venus</span>
      <span style="background-color:#009acd;color:#000">Earth</span>
      <span style="background-color:#a63a3a;color:#000">Mars</span>
      <span style="background-color:#ff7f50;color:#000">Jupiter</span>
      <span style="background-color:#fff;color:#000">Asteroids</span>
-->
		</div>
	</div>
  <script src="vendor/three.js/Three.min.js"></script>
  <script src="vendor/three.js/Detector.js"></script>
  <script src="vendor/three.js/Stats.js"></script>

  <script src="vendor/threex/THREEx.WindowResize.js"></script>
  <script src="vendor/threex/threex.domevent.js"></script>
  <script src="vendor/threex/threex.domevent.object3d.js"></script>
  <script src="js/trackballx.js"></script>
  <script src="vendor/dat.gui.min.js"></script>
  <script src="vendor/date.js"></script>
  <script src="../js/lib/jquery.min.js"></script>
  <script src="js/Worker.js"></script>
  <script src="js/ephemeris.js"></script>
  <script src="js/ellipse.js"></script>
  <script src="js/util.js"></script>
  <script src="js/main.js"></script>
<script type="text/javascript">
if(~document.location.href.indexOf('asterank.com')) {
(function() {
(function(d,c){var a,b,g,e;a=d.createElement("script");a.type="text/javascript";a.async=!0;a.src=("https:"===d.location.protocol?"https:":"http:")+'//api.mixpanel.com/site_media/js/api/mixpanel.2.js';b=d.getElementsByTagName("script")[0];b.parentNode.insertBefore(a,b);c._i=[];c.init=function(a,d,f){var b=c;"undefined"!==typeof f?b=c[f]=[]:f="mixpanel";g="disable track track_pageview track_links track_forms register register_once unregister identify name_tag set_config".split(" ");
for(e=0;e<g.length;e++)(function(a){b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,0)))}})(g[e]);c._i.push([a,d,f])};window.mixpanel=c})(document,[]);
})();
mixpanel.init("6b34941ba1e8a39264cee7fccab432f2");mixpanel.track('3d');
}
else {
  mixpanel = {track: function() {}};
}</script>
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=230286373664292";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</body>
</html>
